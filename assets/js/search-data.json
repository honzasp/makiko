{"0": {
    "doc": "Connecting to the server",
    "title": "Connecting to the server",
    "content": "In this chapter, we will connect to an SSH server and print out the server public key. ",
    "url": "/makiko/tutorial/1-connect.html",
    "relUrl": "/tutorial/1-connect.html"
  },"1": {
    "doc": "Connecting to the server",
    "title": "An example server",
    "content": "To test an SSH client, we need an SSH server! If you have Docker installed, you can run my example SSH server in a Docker container as follows: . $ docker run --rm -p 2222:22 --name example-ssh-server honzasp/makiko-tutorial . This command will start the container in the background and it will bind the server to port 2222 on your localhost. You can connect to this server with username alice and password alicealice: . $ ssh -p 2222 alice@localhost . To stop the container, you can run: . $ docker stop example-ssh-server . If using Docker is not convenient for you, you can follow the tutorial by connecting to another SSH server that you can access, but you will need to adjust the connection details in the code. ",
    "url": "/makiko/tutorial/1-connect.html#example-server",
    "relUrl": "/tutorial/1-connect.html#example-server"
  },"2": {
    "doc": "Connecting to the server",
    "title": "Open the connection",
    "content": "We will put all our code in src/main.rs. Makiko uses Tokio and async, so our main function looks as follows: . #[tokio::main] async fn main() { ... // Our code will go here } . We use the #[tokio::main] attribute to conveniently initialize the Tokio runtime and enable async code in main(). You may wonder why we don’t return a Result from main(). To keep things simple in the tutorial, we will panic when we encounter an error. In real code, you should handle errors properly. The socket . First, we need to open a TCP socket to the SSH server. Makiko can work with anything that implements AsyncRead and AsyncWrite, so you can also use Unix domain sockets, pipes or other exotic modes of transport. However, a tokio::net::TcpStream will be the most usual choice: . let socket = tokio::net::TcpStream::connect((\"localhost\", 2222)).await .expect(\"Could not open a TCP socket\"); . Configuration . The SSH protocol supports many cryptographic algorithms for different aspects of the connection, such as key exchange or encryption. We need to configure the client using the makiko::ClientConfig struct, which specifies the algorithms that the client can use and other low-level details. In most cases, you can use the default configuration, which uses only very secure cryptography: . // Recommended configuration that uses only the best crypto let config = makiko::ClientConfig::default(); . However, if you need to connect to older SSH servers that don’t support the newest crypto, you can use configuration that allows all algorithms implemented in Makiko. None of these algorithms are known to be broken, but they use primitives with known weaknesses (such as HMAC with SHA-1), are considered suspicious (NIST elliptic curves) or have suboptimal implementation in Makiko (Diffie-Hellman key exchange). // Less secure configuration compatible with almost all SSH servers let config = makiko::ClientConfig::default_compatible_less_secure(); . If you want more fine-grained configuration, please see the documentation. The client . We now have all that is needed to open the makiko::Client: . let (client, mut client_rx, client_fut) = makiko::Client::open(socket, config) .expect(\"Could not open client\"); . The Client::open() associated function returns three objects: a Client, a ClientReceiver and a ClientFuture. In the next sections, we will deal with the ClientReceiver and ClientFuture, and the following chapters will make use of the Client. ",
    "url": "/makiko/tutorial/1-connect.html#open-the-connection",
    "relUrl": "/tutorial/1-connect.html#open-the-connection"
  },"3": {
    "doc": "Connecting to the server",
    "title": "Polling the client",
    "content": "To handle the SSH connection, we need to asynchronously run the code that performs I/O on the underlying socket. This code is encapsulated in the ClientFuture, which is a Rust Future that you need to poll to drive the connection forward. The future is resolved when the client is closed or when the connection fails with an error. In this tutorial, we will simply spawn a Tokio task to poll the future in the background and panic when the connection fails: . tokio::task::spawn(async move { client_fut.await.expect(\"Error in client future\"); }); . When we drop the JoinHandle returned from spawn(), Tokio will detach the task and run it in the background. This works well in our tutorial, but in practice, it is usually better to follow the principles of structured concurrency and always .await all tasks that you spawn. This will make sure that errors are always handled correctly, resources are cleaned up, and your program becomes easier to reason about. ",
    "url": "/makiko/tutorial/1-connect.html#polling-the-client",
    "relUrl": "/tutorial/1-connect.html#polling-the-client"
  },"4": {
    "doc": "Connecting to the server",
    "title": "Handle client events",
    "content": "During the lifetime of the SSH connection, the client will asynchronously produce various events. To handle these events, we will use the ClientReceiver. This is a bit similar to channels in Tokio: Makiko sends events to this “channel”, and you receive them using ClientReceiver::recv(), which is like the Receiver::recv() method of a Tokio channel: . loop { // Wait for the next event. let event = client_rx.recv().await .expect(\"Error while receiving client event\"); // Exit the loop when the client has closed. let Some(event) = event else { break }; match event { ... // We will handle the event here } } . Server public key . The produced events are variants of the enum ClientEvent. The most important variant that you always need to handle is ClientEvent::ServerPubkey, which you will get when Makiko receives the server’s public key during key exchange. This always happens when the connection is initialized, but you may also get this event after the connection is established if the connection is “rekeyed” to derive fresh encryption secrets. match event { // Handle the server public key makiko::ClientEvent::ServerPubkey(pubkey, accept) =&gt; { ... // Verify the server public key here }, ... // Handle other events here } . The ServerPubkey variant has two fields: the server Pubkey and an AcceptPubkey object that we will use to tell Makiko whether we accept or reject the key. To prevent man-in-the-middle attacks, it is very important to verify that this public key belongs to the server that we wanted to connect to. Unfortunately, SSH does not provide any mechanism to verify identity of the server (in contrast to TLS, which is used in HTTPS to secure the Web and which provides certificate-based public key infrastructure). This means that it is up to you whether to accept or reject the public key. Later in the tutorial, we will learn how to implement a trust on first use (TOFU) scheme using the standard ~/.ssh/known_hosts file. But for now, we won’t do any verification and we will accept any key: . match event { // Handle the server public key: for now, we just accept all keys, but this makes // us susceptible to man-in-the-middle attacks! makiko::ClientEvent::ServerPubkey(pubkey, accept) =&gt; { println!(\"Server pubkey type {}, fingerprint {}\", pubkey.type_str(), pubkey.fingerprint()); accept.accept(); }, ... } . If you don’t verify the server public key, it might be treated as a security vulnerability. Other events . You can read the documentation if you want to learn about other client events, but we won’t need to handle them in this tutorial, so we can just ignore them: . match event { ... // All other events can be safely ignored _ =&gt; {}, } . You can find the full code for this tutorial in examples/tutorial_1.rs. If all works well, the program prints the fingerprint of the server public key and hangs. In the next chapter, we will continue by authenticating to the server using a password. Next: Password authentication . ",
    "url": "/makiko/tutorial/1-connect.html#handle-client-events",
    "relUrl": "/tutorial/1-connect.html#handle-client-events"
  },"5": {
    "doc": "Password authentication",
    "title": "Password authentication",
    "content": "In this chapter, we will authenticate to the SSH server using a password. Public key authentication, which is described in the next chapter, is considered more secure than password authentication and should be preferred whenever possible, especially if you cannot securely verify the public key of the server that you are connecting to. ",
    "url": "/makiko/tutorial/2-password-auth.html",
    "relUrl": "/tutorial/2-password-auth.html"
  },"6": {
    "doc": "Password authentication",
    "title": "Handle client events in a task",
    "content": "In the previous chapter, we spawned a task to poll the ClientFuture and we waited for ClientEvent-s from the ClientReceiver on the main task. However, from now on, we will need the main task to invoke operations on the Client, so we start by moving the event handling from the main task to another spawned task: . // Do not handle the client events on the main task /* loop { // Wait for the next event. let event = client_rx.recv().await .expect(\"Error while receiving client event\"); ... } */ // Instead, spawn another Tokio task to handle the client events. tokio::task::spawn(async move { loop { // Wait for the next event. let event = client_rx.recv().await .expect(\"Error while receiving client event\"); ... // Handle the events as before } }); . ",
    "url": "/makiko/tutorial/2-password-auth.html#handle-client-events-in-a-task",
    "relUrl": "/tutorial/2-password-auth.html#handle-client-events-in-a-task"
  },"7": {
    "doc": "Password authentication",
    "title": "Authenticate",
    "content": "Back on the main task, we can now call the Client::auth_password() method to attempt password authentication using username “alice” and password “alicealice”: . // Try to authenticate using a password. let auth_res = client.auth_password(\"alice\".into(), \"alicealice\".into()).await .expect(\"Error when trying to authenticate\"); . The method returns an AuthPasswordResult, which has these variants: . | Success means that we are now authenticated. | Failure means that the server has not accepted the authentication and provided an AuthFailure with details. | ChangePassword means that the password was correct, but we need to change the password to a new one. The SSH specification provides a mechanism for changing the password, but I have not found any SSH server or client that implements this feature, so Makiko does not support it either. This means that we don’t need to handle the ChangePassword variant in practice, so we treat it as an error. | . In this tutorial, we can simply print a message on success and panic on failure: . // Deal with all possible outcomes of password authentication. match auth_res { makiko::AuthPasswordResult::Success =&gt; { println!(\"We have successfully authenticated using a password\"); }, makiko::AuthPasswordResult::ChangePassword(prompt) =&gt; { panic!(\"The server asks us to change password: {:?}\", prompt); }, makiko::AuthPasswordResult::Failure(failure) =&gt; { panic!(\"The server rejected authentication: {:?}\", failure); } } . Full code for this tutorial can be found in examples/tutorial_2.rs. The program will print a message if the authentication was successful, or an error if it failed. If you don’t use the example server for this tutorial, you may need to change the code to use a different username and password. Next: Public key authentication . ",
    "url": "/makiko/tutorial/2-password-auth.html#authenticate",
    "relUrl": "/tutorial/2-password-auth.html#authenticate"
  },"8": {
    "doc": "Public key authentication",
    "title": "Public key authentication",
    "content": "In this chapter, we will authenticate to the SSH server using a private key. With this authentication method, we send a public key to the server and we cryptographically prove that we own the corresponding private key. However, our private key is not transmitted, so it stays secure even if we connect to an untrusted server. The server then decides whether to accept the public key, for example by consulting a list of public keys stored in the ~/.ssh/authorized_keys file on the server. ",
    "url": "/makiko/tutorial/3-pubkey-auth.html",
    "relUrl": "/tutorial/3-pubkey-auth.html"
  },"9": {
    "doc": "Public key authentication",
    "title": "Get the private key",
    "content": "Makiko supports several types of public/private keys: . | RSA is the original public key cryptosystem based on integer factorization, which is still widely deployed. The theoretical algorithm is sound, but practical implementations of RSA have a long history of being subtly flawed, so using RSA is discouraged. | Elliptic curve cryptography is a more modern class of public key algorithms that are based on elliptic curves. Makiko supports: . | ECDSA is a standardized signature algorithm scheme based on elliptic curves. Makiko supports ECDSA with two curves, NIST P-256 and NIST P-384. However, there have been suspicions that these curves may contain a backdoor, because they are generated using parameters that have not been fully explained. | EdDSA is a different signature algorithm scheme. Makiko supports the algorithm Ed25519, which uses Curve25519. This algorithm is fast and is considered very secure. | . | . In Makiko, public keys are represented as the enum Pubkey and private keys as the enum Privkey. You can always obtain the public key from the private key by calling Privkey::pubkey(). File formats for private keys . To authenticate with public key authentication, we need to obtain the private key. Makiko can read private keys in the following formats: . | PKCS#1: Legacy format for RSA keys, uses ASN.1 and encodes the key using the DER encoding. | PKCS#8: A newer format that can encode keys from different public key algorithms. This format is common when working with TLS and other cryptography applications. It is also based on ASN.1 and uses DER encoding. | OpenSSH: A format for private keys that is used by OpenSSH. The key is not encoded using DER but with the same encoding that is used in the SSH protocol. | . Private keys in these formats may also be encrypted. Makiko supports decrypting private keys in PKCS#8 and OpenSSH formats; encrypted keys in the PKCS#1 format are not supported. All these formats are binary. To make them easier to use, they are usually stored in PEM format, which encodes the binary data in a textual form. PEM files can be easily recognized by starting with -----BEGIN &lt;tag&gt;-----, followed by base64-encoded data and ending with -----END &lt;tag&gt;-----, where &lt;tag&gt; is a string that determines the format of the binary data: . | -----BEGIN PRIVATE KEY----- is a private key in PKCS#8 format, | -----BEGIN RSA PRIVATE KEY----- is a private key in PKCS#1 format, | -----BEGIN OPENSSH PRIVATE KEY----- is a private key in OpenSSH format, and | -----BEGIN ENCRYPTED PRIVATE KEY----- is an encrypted private key in PKCS#8 format. | . PEM files can also store other types of cryptographic material such as certificates (-----BEGIN CERTIFICATE-----). Decode the private key . In Makiko, the makiko::keys module contains functions for decoding from all these formats, both binary and PEM. For the common case of reading an unencrypted private key from PEM, you can use the function decode_pem_privkey_nopass, which automatically detects the format of the key from the PEM tag. This function returns an enum DecodedPrivkeyNopass, which can take one of these variants: . | Privkey if we successfully decoded the private key. | Pubkey if the private key was encrypted, but we could at least decode the public key. This is supported only by the OpenSSH format. | Encrypted if the file was encrypted and we could not decode anything. | . We will just use the DecodedPrivkeyNopass::privkey() convenience method to get the private key, if it is available. However, in a real application, we may want to prompt the user for the password if the key is encrypted. // Decode our private key from PEM. let privkey = makiko::keys::decode_pem_privkey_nopass(PRIVKEY_PEM) .expect(\"Could not decode a private key from PEM\") .privkey().cloned() .expect(\"Private key is encrypted\"); . In this tutorial, we simply hard-coded the private key, but in practice, you would usually read the key from a file or from configuration. const PRIVKEY_PEM: &amp;[u8] = br#\" -----BEGIN OPENSSH PRIVATE KEY----- b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAAAMwAAAAtzc2gtZW QyNTUxOQAAACDyVJsRfh+NmkQKg2Dh6rPVodiQ3nC+dVoGMoMtYcbMJQAAAJBPdwHAT3cB wAAAAAtzc2gtZWQyNTUxOQAAACDyVJsRfh+NmkQKg2Dh6rPVodiQ3nC+dVoGMoMtYcbMJQ AAAEA5ct+xfc9qlJ4I2Jee8HIrAhN55yxmtUmvKpjT7q6QXPJUmxF+H42aRAqDYOHqs9Wh 2JDecL51WgYygy1hxswlAAAABmVkd2FyZAECAwQFBgc= -----END OPENSSH PRIVATE KEY----- \"#; . Never hard-code private keys or other credentials into your program in practice! . ",
    "url": "/makiko/tutorial/3-pubkey-auth.html#get-the-private-key",
    "relUrl": "/tutorial/3-pubkey-auth.html#get-the-private-key"
  },"10": {
    "doc": "Public key authentication",
    "title": "Authenticate",
    "content": "Once we have the private key, we need to select the signing algorithm that we will use for authentication. For ECDSA and EdDSA keys, the algorithm is determined by the key type, but for RSA keys, multiple algorithms are applicable. The RSA algorithms differ in the hash function that is used during signing: the original algorithm “ssh-rsa” uses the SHA-1 hash algorithm, which was found to be insecure, so the protocol was extended with new algorithms that replace the hash function with SHA-2 (Makiko supports “rsa-sha2-256” and “rsa-sha2-512”). These new algorithms work with the same keys as the old “ssh-rsa” algorithm, the only difference is in the mechanism that the client uses to prove to the server that it knows the private key. All public key algorithms supported in Makiko are listed in the makiko::pubkey module. In this chapter, we know that the private key that we decoded in the previous section is an Ed25519 key, so there is just a single applicable algorithm, “ssh-ed25519”. In the next chapter, we will see how to select the algorithm more robustly. // Select an algorithm for public key authentication. let pubkey_algo = &amp;makiko::pubkey::SSH_ED25519; . We can now call the Client::auth_pubkey() method to authenticate with username “edward” and the private key: . // Try to authenticate with the private key let auth_res = client.auth_pubkey(\"edward\".into(), privkey, pubkey_algo).await .expect(\"Error when trying to authenticate\"); . The method returns an AuthPubkeyResult, which is either a Success or Failure: . // Deal with the possible outcomes of public key authentication. match auth_res { makiko::AuthPubkeyResult::Success =&gt; { println!(\"We have successfully authenticated using a private key\"); }, makiko::AuthPubkeyResult::Failure(failure) =&gt; { panic!(\"The server rejected authentication: {:?}\", failure); } } . Full code for this tutorial can be found in examples/tutorial_3.rs. The program will print a message if the authentication was successful, or an error if it failed. If you don’t use the example server for this tutorial, you may need to change the code to use a different username and private key. Next: Public key algorithm . ",
    "url": "/makiko/tutorial/3-pubkey-auth.html#authenticate",
    "relUrl": "/tutorial/3-pubkey-auth.html#authenticate"
  },"11": {
    "doc": "Public key algorithm",
    "title": "Public key algorithm",
    "content": "This chapter will build on the previous chapter by selecting the public key algorithm more robustly. ",
    "url": "/makiko/tutorial/4-pubkey-algo.html",
    "relUrl": "/tutorial/4-pubkey-algo.html"
  },"12": {
    "doc": "Public key algorithm",
    "title": "Get the list of supported algorithms",
    "content": "We can use the Privkey::pubkey() method to obtain the Pubkey from the Privkey that we have read from PEM in the previous chapter: . // Get the public key from the private key. let pubkey = privkey.pubkey(); . And to obtain the list of algorithms that Makiko supports for this public key, we can use the Pubkey::algos() method: . // Get the public key algorithms supported by the key. let available_algos = pubkey.algos(); . Next, we need to find out which of these algorithms is also supported by the server. ",
    "url": "/makiko/tutorial/4-pubkey-algo.html#get-the-list-of-supported-algorithms",
    "relUrl": "/tutorial/4-pubkey-algo.html#get-the-list-of-supported-algorithms"
  },"13": {
    "doc": "Public key algorithm",
    "title": "Check public keys and an algorithms",
    "content": "Armed with the private key and a list of algorithms, we could simply try to call Client::auth_pubkey() with each algorithm in turn. This is a reasonable approach, but it has two disadvantages: . | SSH servers typically limit the number of failed authentication attempts to a small number and will close the connection when this limit is exceeded. | The signing operation that is required for authentication might be expensive in terms of CPU time. | . Fortunately, the SSH protocol provides a mechanism to ask the server whether it would accept a given combination of public key and algorithm, without actually attempting the authentication. We can use this mechanism by calling Client::check_pubkey(), which takes the username, public key and public key algorithm, and returns a bool: . // Try the algorithms one by one. let username: String = \"ruth\".into(); for pubkey_algo in available_algos.iter().copied() { // Check whether this combination of a public key and algorithm would be acceptable to the // server. let check_ok = client.check_pubkey(username.clone(), &amp;pubkey, pubkey_algo).await .expect(\"Error when checking a public key\"); ... } . If the server says that it will not accept this public key and algorithm, we can try the next algorithm: . for pubkey_algo in ... { let check_ok = ...; // Skip this algorithm if the server rejected it. if !check_ok { println!(\"Server rejected public key and algorithm {:?}\", pubkey_algo.name); continue; } ... } . Otherwise, we can try to authenticate: . for pubkey_algo in ... { ... // Try to authenticate using this algorithm. let auth_res = client.auth_pubkey(username.clone(), privkey.clone(), pubkey_algo).await .expect(\"Error when trying to authenticate\"); match auth_res { makiko::AuthPubkeyResult::Success =&gt; { println!(\"We have successfully authenticated using algorithm {:?}\", pubkey_algo.name); break; }, makiko::AuthPubkeyResult::Failure(_) =&gt; { println!(\"Authentication using public key and algorithm {:?} failed\", pubkey_algo.name); }, } } . Finally, we can use the Client::is_authenticated() method to check whether we have been successful: . // Check that we have been authenticated. if !client.is_authenticated().unwrap() { panic!(\"Could not authenticate\"); } . Full code for this tutorial can be found in examples/tutorial_4.rs. The program will print messages about the authentication attemps, and it will panic if authentication fails. If you don’t use the example server for this tutorial, you may need to change the code to use a different username and private key. Next: Execute a command . ",
    "url": "/makiko/tutorial/4-pubkey-algo.html#check-public-keys-and-an-algorithms",
    "relUrl": "/tutorial/4-pubkey-algo.html#check-public-keys-and-an-algorithms"
  },"14": {
    "doc": "Execute a command",
    "title": "Execute a command",
    "content": "In the previous chapters, we connected to the server and authenticated ourselves, so now we can finally execute some commands! . ",
    "url": "/makiko/tutorial/5-execute-command.html",
    "relUrl": "/tutorial/5-execute-command.html"
  },"15": {
    "doc": "Execute a command",
    "title": "Session",
    "content": "A single SSH connection can host multiple logical channels of communication. The SSH protocol defines two kinds of channels: interactive sessions and TCP/IP forwarding channels (or tunnels). In this chapter, we will learn how to use sessions to execute commands, and the next chapter will be about tunnels. One session corresponds to one process: you open a session, prepare the execution environment (such as environment variables), start the command or shell, and then interact with it. ",
    "url": "/makiko/tutorial/5-execute-command.html#session",
    "relUrl": "/tutorial/5-execute-command.html#session"
  },"16": {
    "doc": "Execute a command",
    "title": "Open a session",
    "content": "To open a session, we use the method Client::open_session() (after we have authenticated successfully). To configure the underlying channel, this method needs a ChannelConfig. You can adjust the configuration if you need to optimize the SSH flow control, but the default instance should work well for most use cases: . // Open a session on the server. let channel_config = makiko::ChannelConfig::default(); let (session, mut session_rx) = client.open_session(channel_config).await .expect(\"Could not open a session\"); . The open_session() method returns two objects, a Session and a SessionReceiver. This is the same pattern as with Client and ClientReceiver: you use the Session object to invoke operations on the session, and the SessionReceiver object to receive events from the session. ",
    "url": "/makiko/tutorial/5-execute-command.html#open-a-session",
    "relUrl": "/tutorial/5-execute-command.html#open-a-session"
  },"17": {
    "doc": "Execute a command",
    "title": "Handle session events",
    "content": "To handle events from the SessionReceiver, we will spawn another task, like we did with client events. To receive the events, we will use the method SessionReceiver::recv(). The events are represented using the enum SessionEvent. The recv() method returns None when the session is closed and no more events will be received: . tokio::task::spawn(async move { loop { // Wait for the next event. let event = session_rx.recv().await .expect(\"Error while receiving session event\"); // Exit the loop when the session has closed. let Some(event) = event else { break }; match event { ... // We will handle the event here } } }); . You have to receive the events from the SessionReceiver even if you don’t need to handle them (which should be rare). Makiko internally uses a channel to send events to the SessionReceiver, and if you don’t receive the events, this channel will become full and the client will block. Output from the process . Output from the process is received as StdoutData and StderrData variants of SessionEvent: . match event { // Handle stdout/stderr output from the process. makiko::SessionEvent::StdoutData(data) =&gt; { println!(\"Process produced stdout: {:?}\", data); }, makiko::SessionEvent::StderrData(data) =&gt; { println!(\"Process produced stderr: {:?}\", data); }, ... } . The data is received as chunks of bytes, but the boundaries between the chunks are not meaningful, you should treat stdout and stderr as byte streams. Process exit . When the process exits, the SSH server sends an ExitStatus if the process exited with a status, or ExitSignal if it was killed by a signal: . match event { ... // Handle exit of the process. makiko::SessionEvent::ExitStatus(status) =&gt; { println!(\"Process exited with status {}\", status); }, makiko::SessionEvent::ExitSignal(signal) =&gt; { println!(\"Process exited with signal {:?}: {:?}\", signal.signal_name, signal.message); }, ... } . Other events . The server may also send an Eof event after the process closes its stdout and stderr. We will ignore this event, together with any other events that might be introduced in future versions of the library: . match event { ... // Ignore other events _ =&gt; {}, } . Note that the SessionEvent enum is marked as #[non_exhaustive], so the Rust compiler will require you to add the catch-all match clause even if you handle all variants of the enum. This allows us to add new kinds of events to Makiko without breaking your code. ",
    "url": "/makiko/tutorial/5-execute-command.html#handle-session-events",
    "relUrl": "/tutorial/5-execute-command.html#handle-session-events"
  },"18": {
    "doc": "Execute a command",
    "title": "Execute the command",
    "content": "The session is now ready, so we can execute the command using Session::exec(). We will execute the command sed s/blue/green/g, which reads lines from the standard input, replaces blue with green, and prints the lines back to stdout: . // Execute a command on the session session.exec(\"sed s/blue/green/\".as_bytes()) .expect(\"Could not execute a command in the session\") .wait().await .expect(\"Server returned an error when we tried to execute a command in the session\"); . The exec() method returns a SessionResp, which represents the server response to the execute request. We wait for the response using SessionResp::wait(), but you can also ignore the response with SessionResp::ignore() . ",
    "url": "/makiko/tutorial/5-execute-command.html#execute-the-command",
    "relUrl": "/tutorial/5-execute-command.html#execute-the-command"
  },"19": {
    "doc": "Execute a command",
    "title": "Send data to the process",
    "content": "We will use the Session::send_stdin() method to send data to the standard input of the running process, and Session::send_eof() to send end-of-file, which will close the standard input: . // Send some data to the standard input of the process session.send_stdin(\"blueberry jam\\n\".into()).await.unwrap(); session.send_stdin(\"blue jeans\\nsky blue\".into()).await.unwrap(); session.send_eof().await.unwrap(); . ",
    "url": "/makiko/tutorial/5-execute-command.html#send-data-to-the-process",
    "relUrl": "/tutorial/5-execute-command.html#send-data-to-the-process"
  },"20": {
    "doc": "Execute a command",
    "title": "Wait for the session",
    "content": "We have started the process and sent some data to it, and now we need to wait until the process terminates and the session is closed. Recall that when the session is closed, the SessionReceiver returns None, we break out of the event handling loop and the task terminates. We will change the code that we have written previously to store the JoinHandle from the spawn() call: . let session_event_task = tokio::task::spawn(async move { loop { let event = ...; } }); . Back on the main task, we will wait for the event-handling task to terminate: . // Wait for the task that handles session events session_event_task.await.unwrap(); . Full code for this tutorial can be found in examples/tutorial_5.rs. If you don’t use the example server for this tutorial, you may need to change the code to use a different username and password. Next: Open a tunnel . ",
    "url": "/makiko/tutorial/5-execute-command.html#wait-for-the-session",
    "relUrl": "/tutorial/5-execute-command.html#wait-for-the-session"
  },"21": {
    "doc": "Open a tunnel",
    "title": "Open a tunnel",
    "content": "SSH is most commonly used to execute commands on a remote server, but another important use of the protocol is for tunnelling TCP/IP connections. There are two ways to open a tunnel: . | Local forwarding (aka ssh -L): the client asks the server to open a TCP connection to another host. In Makiko, this is implemented by Client::connect_tunnel(). In this chapter, we will learn how to use this method. | Remote forwarding (aka ssh -R): the client asks the server to listen on a port, and the server will open a tunnel for every TCP connection on this port. In Makiko, this is implemented by Client::bind_tunnel(), Client::unbind_tunnel() and the ClientEvent::Tunnel variant of ClientEvent. We won’t cover remote forwarding in this tutorial, please refer to the API documentation for details. | . ",
    "url": "/makiko/tutorial/6-open-tunnel.html",
    "relUrl": "/tutorial/6-open-tunnel.html"
  },"22": {
    "doc": "Open a tunnel",
    "title": "Open a tunnel",
    "content": "To demonstrate the use of tunnels, we will open a TCP/IP connection from the server to httpbin.org and we will manually send a simple HTTP request over this connection. To open the tunnel, we use the method Client::connect_tunnel(), which needs: . | A ChannelConfig, which configures the underlying SSH channel. Similar to the previous chapter, you can change the configuration to tune performance, but the default configuration should be sufficient for now. | The address that the server will connect to, given as a pair of host and port. The host can be specified as an IP address or as a domain name. We will connect to \"httpbin.org\" on port 80. | The address of the “originator” of the connection. This is also specified as a pair of host and port, but the host should be an IP address. For example, ssh -L will set this to the remote address of the local connection that is forwarded to the server, but we will use the null IP address and port in this tutorial. | . // Open a tunnel from the server. let channel_config = makiko::ChannelConfig::default(); let connect_addr = (\"httpbin.org\".into(), 80); let origin_addr = (\"0.0.0.0\".into(), 0); let (tunnel, mut tunnel_rx) = client.connect_tunnel(channel_config, connect_addr, origin_addr).await .expect(\"Could not open a tunnel\"); . In a direct analogy to Client::open_session(), the Client::connect_tunnel() method returns a pair of objects: a Tunnel object to send requests to the tunnel, and a TunnelReceiver to receive events from the tunnel. ",
    "url": "/makiko/tutorial/6-open-tunnel.html",
    "relUrl": "/tutorial/6-open-tunnel.html"
  },"23": {
    "doc": "Open a tunnel",
    "title": "Handle tunnel events",
    "content": "We will use the same pattern as before to handle events from the tunnel: we spawn a task and receive the events, represented as enum TunnelEvent, using TunnelReceiver::recv(). This method returns None when the tunnel closes: . let tunnel_event_task = tokio::task::spawn(async move { loop { // Wait for the next event. let event = tunnel_rx.recv().await .expect(\"Error while receiving tunnel event\"); // Exit the loop when the tunnel has closed. let Some(event) = event else { break }; match event { ... // Handle the event } } }); . As with all Receiver objects in Makiko, you must receive the events from the TunnelReceiver in a timely manner. Makiko uses a bounded buffer of events, which will become full if you don’t receive the event, causing the client to block. Data received from the channel . Events on a tunnel are quite simple, you can either get a chunk of data with the Data variant, or an end-of-file event with the Eof variant: . match event { // Handle data received from the tunnel. makiko::TunnelEvent::Data(data) =&gt; { println!(\"Received: {:?}\", data); }, // Handle EOF from the tunnel. makiko::TunnelEvent::Eof =&gt; { println!(\"Received eof\"); break }, _ =&gt; {}, } . ",
    "url": "/makiko/tutorial/6-open-tunnel.html#handle-tunnel-events",
    "relUrl": "/tutorial/6-open-tunnel.html#handle-tunnel-events"
  },"24": {
    "doc": "Open a tunnel",
    "title": "Send data to the channel",
    "content": "Back on the main task, we can use the Tunnel::send_data() method to send bytes over the tunnel. In our case, we send a very simple HTTP request to httpbin.org/get: . // Send data to the tunnel tunnel.send_data(\"GET /get HTTP/1.0\\r\\nhost: httpbin.org\\r\\n\\r\\n\".into()).await .expect(\"Could not send data to the tunnel\"); . We can also close the tunnel for sending by calling Tunnel::send_eof(). However, the OpenSSH server will close the tunnel prematurely if we do so, so we comment out this call: . // Do not close the outbound side of the tunnel, because this causes OpenSSH to prematurely // close the tunnel. /* tunnel.send_eof().await .expect(\"Could not send EOF to the tunnel\"); */ . Finally, we wait until the tunnel is closed and the event handling task terminates: . // Wait for the task that handles tunnel events tunnel_event_task.await.unwrap(); . Full code for this tutorial can be found in examples/tutorial_6.rs. If you don’t use the example server for this tutorial, you may need to change the code to use a different username and password. Next: Verify the server key . ",
    "url": "/makiko/tutorial/6-open-tunnel.html#send-data-to-the-channel",
    "relUrl": "/tutorial/6-open-tunnel.html#send-data-to-the-channel"
  },"25": {
    "doc": "Verify the server key",
    "title": "Verify the server key",
    "content": "Back in chapter 1, we said that we should verify the public key presented by the server during the initial connection handshake (or during any follow-up key exchange). The SSH protocol does not contain any mechanism for verifying the server key, so you must do it yourself using a method that suits your application. For example, you can check that the key provided by the server belongs to an allowed set of keys configured with the client. For some applications, not verifying the key may also be a valid approach, but please make sure that you understand the implications. Reading about man-in-the-middle attacks in the SSH protocol architecture RFC might be a good start. The SSH protocol does not verify the public key (it does not check that it belongs to the server that you wanted to connect to), but it does verify that the server owns the corresponding private key. ",
    "url": "/makiko/tutorial/7-verify-pubkey.html",
    "relUrl": "/tutorial/7-verify-pubkey.html"
  },"26": {
    "doc": "Verify the server key",
    "title": "Trust on first use",
    "content": "In this chapter, we will show how you can implement the trust-on-first-use (TOFU) approach for verifying public keys using the well-known ~/.ssh/known_hosts file. With this approach, when we connect to a server, we look up its address in the known_hosts file. If no entry in this file matches the address, it means that we are connecting to the server for the first time, so we accept the server key unconditionally (“trust on first use”) and add an entry to the file. On the other hand, if the file contains at least one entry that matches the address, we check that the key provided by the server is equal to the key from one of the matched entries. If the key fails this check, it means that the server key has changed from the last time that we connected to the server, which may mean that somebody is attempting a man-in-the-middle attack, so we reject the key, which aborts the connection. (This is the “IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!” error that you may have encountered when using the ssh client from OpenSSH.) . It is important to use the hostname of the SSH server as specified by the user when searching for entries in the known_hosts file. For example, if the user specifies a domain name, we must look up the domain name and not the resolved IP address, because an attacker can modify the DNS record of the server to point to a different IP address. In the rest of this chapter, we will be writing code that handles the ClientEvent::ServerPubkey event: . match event { makiko::ClientEvent::ServerPubkey(pubkey, accept) =&gt; { println!(\"Server pubkey type {}, fingerprint {}\", pubkey.type_str(), pubkey.fingerprint()); ... // Verify the `pubkey` and call `accept.accept()` if it is valid }, } . ",
    "url": "/makiko/tutorial/7-verify-pubkey.html#trust-on-first-use",
    "relUrl": "/tutorial/7-verify-pubkey.html#trust-on-first-use"
  },"27": {
    "doc": "Verify the server key",
    "title": "Read the known_hosts file",
    "content": "Makiko provides support for reading a known_hosts file using features from the host_file module. Makiko can read the file, but it can also append new entries to the file and losslessly write the updated file back. We start by locating the file and reading its contents into memory: . // Read the ~/.ssh/known_hosts file. let hosts_path = home::home_dir().unwrap().join(\".ssh/known_hosts\"); let hosts_data = std::fs::read(&amp;hosts_path) .expect(\"Could not read known_hosts file\"); . We have used the home crate to reliably find the user’s home directory, so you may need to add it to your Cargo.toml: . [dependencies] home = \"0.5\" . We can now use the host_file::File::decode() method to parse the file and get a host_file::File. Note that this method does not return a Result: when it encounters invalid or unrecognized lines, it simply ignores them (but keeps them around, so that we can later losslessly encode the file back). // Decode the contents of the file. let mut hosts_file = makiko::host_file::File::decode(hosts_data.into()); . ",
    "url": "/makiko/tutorial/7-verify-pubkey.html#read-the-known_hosts-file",
    "relUrl": "/tutorial/7-verify-pubkey.html#read-the-known_hosts-file"
  },"28": {
    "doc": "Verify the server key",
    "title": "Lookup the server address",
    "content": "The known_hosts file is a sequence of entries (host_file::Entry). Every entry stores a single public key and it contains a pattern that can match an address. The pattern might be a concrete hostname (such as github.com, 140.82.121.4 or [localhost]:2222), a wildcard pattern (such as *.github.com or g?thub.com) or a hash of the hostname (|1|4n/lI1Js...my6Q=). The hashed pattern is usually preferred, because it hides the identity of SSH servers that you have connected to, in case your known_hosts file is leaked. Some entires may also be marked as revoked, which means that the public key should be rejected instead of accepted. We can use the method host_file::File::match_host_port_key() to search for all entries that match the given host and port. The result of this search is a host_file::KeyMatch: . // Lookup the server address in the file. let key_match = hosts_file.match_host_port_key(host, port, &amp;pubkey); . ",
    "url": "/makiko/tutorial/7-verify-pubkey.html#lookup-the-server-address",
    "relUrl": "/tutorial/7-verify-pubkey.html#lookup-the-server-address"
  },"29": {
    "doc": "Verify the server key",
    "title": "Deal with the result of the lookup",
    "content": "There are four variants of the host_file::KeyMatch enum, so we need to handle them all: . match key_match { ... } . Key is present in the file . The Accepted variant means that the known_hosts file contains at least one entry that matches the hostname and which refers to the public key provided by the server. This means that we have previously decided to trust this key for this hostname, so we can call AcceptPubkey::accept() to accept the key: . match key_match { // The given key was found in the file, this means that it is trusted and we // can accept it. makiko::host_file::KeyMatch::Accepted(entries) =&gt; { println!(\"Found the server key in known_hosts file\"); for entry in entries.iter() { println!(\"At line {}\", entry.line()); } accept.accept(); }, ... } . Key was revoked . The Revoked variant means that there was an entry that lists the key as revoked for the hostname, so we must reject the key. You can call AcceptPubkey::reject() with a custom error that describes the reason for the rejection, or you can simply drop the AcceptPubkey object, which will reject the key with a default error: . match key_match { ... // The key was revoked in the file, so we must reject it. makiko::host_file::KeyMatch::Revoked(_entry) =&gt; { println!(\"The server key was revoked in known_hosts file\"); }, ... } . Other keys found in the file . The OtherKeys variant means that we found entries that match the hostname, but all of them specified a different public key. This means that we already know the valid keys of this server, but the server provided a different key, so we must reject the key, because a man-in-the-middle attack might be going on: . match key_match { ... // We found other keys for this server in the file, so the server changed its // key, or somebody is doing a man-in-the-middle attack on us. makiko::host_file::KeyMatch::OtherKeys(entries) =&gt; { println!(\"The known_hosts file specifies other keys for this server:\"); for entry in entries.iter() { println!(\"At line {}, pubkey type {}, fingerprint {}\", entry.line(), entry.pubkey().type_str(), entry.pubkey().fingerprint()); } println!(\"Aborting, you might be target of a man-in-the-middle attack!\"); }, ... } . No entry was found . Finally, the NotFound variant means that the file does not contain any entry matching the given hostname. In this case, we may decide to trust the key and add it to the known_hosts file: . match key_match { ... // We did not find the key in the file, so we decide to accept the key and add // it to the file. makiko::host_file::KeyMatch::NotFound =&gt; { println!(\"Did not find any key for this server in known_hosts file, \\ adding it to the file\"); accept.accept(); ... // Add an entry to the file }, } . To add an entry to the host_file::File, we can use the host_file::File::append_entry() method and the host_file::EntryBuilder: . // Append an entry with the key to the file. hosts_file.append_entry( makiko::host_file::File::entry_builder() .host_port(host, port) .key(pubkey) ); . To save the updated file to disk, we will use the host_file::File::encode() method to get the modified contents of the file: . // Write the modified file back to disk. let hosts_data = hosts_file.encode(); std::fs::write(&amp;hosts_path, &amp;hosts_data) .expect(\"Could not write the modified known_hosts file\"); . The encode() method is lossless: it faithfully preserves all existing lines, including comments or invalid lines. Full code for this tutorial can be found in examples/tutorial_7.rs. If you don’t use the example server for this tutorial, you may need to change the code to use a different username and password. This concludes the Makiko tutorial. Thank you for your interest, I hope that the library will be useful to you and that you will enjoy using it! . Next: API documentation . ",
    "url": "/makiko/tutorial/7-verify-pubkey.html#deal-with-the-result-of-the-lookup",
    "relUrl": "/tutorial/7-verify-pubkey.html#deal-with-the-result-of-the-lookup"
  },"30": {
    "doc": "Tutorial",
    "title": "Tutorial",
    "content": "Makiko is an asynchronous SSH client library for Rust. It gives you a lot of control over the SSH connection, but this means that it is quite low-level. In this tutorial, we will connect to a server, authenticate with a password or a public key, execute a command and open a tunnel. I will assume that you know Rust, have some experience with Tokio and have used SSH previously. ",
    "url": "/makiko/tutorial/",
    "relUrl": "/tutorial/"
  },"31": {
    "doc": "Tutorial",
    "title": "The code",
    "content": "If you want to follow along with the tutorial, create a new Rust project using Cargo: . $ cargo new hello_makiko $ cd hello_makiko . And add the dependencies to Makiko and Tokio into your Cargo.toml: . [dependencies] makiko = \"0.2\" tokio = {version = \"1.25\", features = [\"full\"]} . You can also find complete code for each chapter in this tutorial in the examples/ directory in the Makiko repository. In the next chapter, we will start writing the code in src/main.rs. Next: Connecting to the server . ",
    "url": "/makiko/tutorial/#the-code",
    "relUrl": "/tutorial/#the-code"
  },"32": {
    "doc": "Home",
    "title": "Makiko",
    "content": "Makiko is an asynchronous SSH client library in pure Rust . Get started API docs Github Crate . ",
    "url": "/makiko/#makiko",
    "relUrl": "/#makiko"
  },"33": {
    "doc": "Home",
    "title": "Features",
    "content": ". | SSH protocol 2 | Authentication methods: publickey, password, none | Shell/exec sessions | Remote and local tunnels | Raw SSH channels (low-level API) | Ciphers: chacha20-poly1305, aes128-gcm, aes256-gcm, aes128-ctr, aes192-ctr, aes256-ctr, aes128-cbc*, aes192-cbc*, aes256-cbc* | MACs: hmac-sha2-256-etm, hmac-sha2-512-etm, hmac-sha2-256, hmac-sha2-512, hmac-sha1-etm*, hmac-sha1* | Public key algorithms: ssh-ed25519, rsa-sha2-256, rsa-sha2-512, ecdsa-sha2-nistp256*, ecdsa-sha2-nistp384*, ssh-rsa* | Key exchange algorithms: curve25519-sha256, diffie-hellman-group14-sha1*, diffie-hellman-group14-sha256*, diffie-hellman-group16-sha512*, diffie-hellmann-group18-sha512* | Crypto from Rust Crypto | Use your own sockets, spawn your own tasks | Uses Tokio interfaces (but does not depend on the Tokio runtime) | Rust all the way down: no dependency on non-Rust libraries, direct or indirect | . * Algorithms marked with an asterisk are not enabled by default . ",
    "url": "/makiko/#features",
    "relUrl": "/#features"
  },"34": {
    "doc": "Home",
    "title": "Low-level",
    "content": "Makiko gives you a lot of control over the SSH connection, it is meant to be a building block for libraries and advanced applications. Makiko and most of the cryptography crates from Rust Crypto that Makiko uses have not yet been audited by a trusted third party. Use at your own risk! . ",
    "url": "/makiko/#low-level",
    "relUrl": "/#low-level"
  },"35": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "/makiko/",
    "relUrl": "/"
  }
}
